// Code generated by coroc. DO NOT EDIT

//go:build durable

package testdata

import (
	coroutine "github.com/stealthrocket/coroutine"
	time "time"
	unsafe "unsafe"
)

func SomeFunctionThatShouldExistInTheCompiledFile() {
}

//go:noinline
func Identity(n int) { coroutine.Yield[int, any](n) }

//go:noinline
func SquareGenerator(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	if _f.IP > 0 {
		n = _f.Get(0).(int)
		_o0 = _f.Get(1).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		for ; _o0 <= n; _o0, _f.IP = _o0+1, 2 {
			coroutine.Yield[int, any](_o0 * _o0)
		}
	}
}

//go:noinline
func SquareGeneratorTwice(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	if _f.IP > 0 {
		n = _f.Get(0).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		SquareGenerator(n)
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		SquareGenerator(n)
	}
}

//go:noinline
func SquareGeneratorTwiceLoop(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	if _f.IP > 0 {
		n = _f.Get(0).(int)
		_o0 = _f.Get(1).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		for ; _o0 < 2; _o0, _f.IP = _o0+1, 2 {
			SquareGenerator(n)
		}
	}
}

//go:noinline
func EvenSquareGenerator(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	if _f.IP > 0 {
		n = _f.Get(0).(int)
		_o0 = _f.Get(1).(int)
		_o1 = _f.Get(2).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 4:
		for ; _o0 <= n; _o0, _f.IP = _o0+1, 2 {
			switch {
			case _f.IP < 3:
				_o1 = _o0 % 2
				_f.IP = 3
				fallthrough
			case _f.IP < 4:
				if _o1 == 0 {
					coroutine.Yield[int, any](_o0 * _o0)
				}
			}
		}
	}
}

//go:noinline
func NestedLoops(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	var _o2 int
	if _f.IP > 0 {
		n = _f.Get(0).(int)
		_o0 = _f.Get(1).(int)
		_o1 = _f.Get(2).(int)
		_o2 = _f.Get(3).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_f.Set(3, _o2)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 5:
		for ; _o0 <= n; _o0, _f.IP = _o0+1, 2 {
			switch {
			case _f.IP < 3:
				_o1 = 1
				_f.IP = 3
				fallthrough
			case _f.IP < 5:
				for ; _o1 <= n; _o1, _f.IP = _o1+1, 3 {
					switch {
					case _f.IP < 4:
						_o2 = 1
						_f.IP = 4
						fallthrough
					case _f.IP < 5:
						for ; _o2 <= n; _o2, _f.IP = _o2+1, 4 {
							coroutine.Yield[int, any](_o0 * _o1 * _o2)
						}
					}
				}
			}
		}
	}
}

//go:noinline
func FizzBuzzIfGenerator(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	if _f.IP > 0 {
		n = _f.Get(0).(int)
		_o0 = _f.Get(1).(int)

		_o1 = _f.Get(2).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 7:
		for ; _o0 <= n; _o0, _f.IP = _o0+1, 2 {
			if _o0%3 == 0 && _o0%5 == 0 {
				coroutine.Yield[int, any](FizzBuzz)
			} else {
				if _o0%3 == 0 {
					coroutine.Yield[int, any](Fizz)
				} else {
					switch {
					case _f.IP < 5:
						_o1 = _o0 % 5
						_f.IP = 5
						fallthrough
					case _f.IP < 7:
						if _o1 == 0 {
							coroutine.Yield[int, any](Buzz)
						} else {

							coroutine.Yield[int, any](_o0)
						}
					}
				}
			}
		}
	}
}

//go:noinline
func FizzBuzzSwitchGenerator(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 bool
	var _o2 bool
	var _o3 bool
	if _f.IP > 0 {
		n = _f.Get(0).(int)
		_o0 = _f.Get(1).(int)
		_o1 = _f.Get(2).(bool)
		_o2 = _f.Get(3).(bool)
		_o3 = _f.Get(4).(bool)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_f.Set(3, _o2)
			_f.Set(4, _o3)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 9:
		for ; _o0 <= n; _o0, _f.IP = _o0+1, 2 {
			switch {
			default:
				switch {
				case _f.IP < 3:
					_o1 = _o0%3 == 0 && _o0%5 == 0
					_f.IP = 3
					fallthrough
				case _f.IP < 9:
					if _o1 {
						coroutine.Yield[int, any](FizzBuzz)
					} else {
						switch {
						case _f.IP < 5:
							_o2 = _o0%3 == 0
							_f.IP = 5
							fallthrough
						case _f.IP < 9:
							if _o2 {
								coroutine.Yield[int, any](Fizz)
							} else {
								switch {
								case _f.IP < 7:
									_o3 = _o0%5 == 0
									_f.IP = 7
									fallthrough
								case _f.IP < 9:
									if _o3 {
										coroutine.Yield[int, any](Buzz)
									} else {

										coroutine.Yield[int, any](_o0)
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//go:noinline
func Shadowing(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	var _o2 int
	var _o3 int
	var _o4 int
	var _o5 bool
	var _o6 int
	var _o7 int
	var _o8 int
	var _o9 int
	var _o10 int
	var _o11 int

	const _o12 = 11

	const _o13 = 12
	var _o14 int

	type _o15 uint16

	type _o16 uint32
	var _o17 uintptr
	var _o18 int
	var _o19 uintptr
	var _o20 int

	const _o21 = 1
	type _o22 [_o21]uint8

	type _o23 [_o21]uint8
	var _o24 uintptr
	var _o25 int

	const _o26 = unsafe.Sizeof(_o23{}) * 2
	type _o27 [_o26]uint8
	var _o28 uintptr
	var _o29 int
	var _o30 uintptr
	var _o31 int
	if _f.IP > 0 {
		_o0 = _f.Get(0).(int)

		_o1 = _f.Get(1).(int)

		_o2 = _f.Get(2).(int)

		_o3 = _f.Get(3).(int)
		_o4 = _f.Get(4).(int)
		_o5 = _f.Get(5).(bool)

		_o6 = _f.Get(6).(int)
		_o7 = _f.Get(7).(int)

		_o8 = _f.Get(8).(int)

		_o9 = _f.Get(9).(int)

		_o10 = _f.Get(10).(int)

		_o11 = _f.Get(11).(int)

		_o14 = _f.Get(12).(int)
		_o17 = _f.Get(13).(uintptr)
		_o18 = _f.Get(14).(int)
		_o19 = _f.Get(15).(uintptr)
		_o20 = _f.Get(16).(int)
		_o24 = _f.Get(17).(uintptr)
		_o25 = _f.Get(18).(int)
		_o28 = _f.Get(19).(uintptr)
		_o29 = _f.Get(20).(int)
		_o30 = _f.Get(21).(uintptr)
		_o31 = _f.Get(22).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_f.Set(4, _o4)
			_f.Set(5, _o5)
			_f.Set(6, _o6)
			_f.Set(7, _o7)
			_f.Set(8, _o8)
			_f.Set(9, _o9)
			_f.Set(10, _o10)
			_f.Set(11, _o11)
			_f.Set(12, _o14)
			_f.Set(13, _o17)
			_f.Set(14, _o18)
			_f.Set(15, _o19)
			_f.Set(16, _o20)
			_f.Set(17, _o24)
			_f.Set(18, _o25)
			_f.Set(19, _o28)
			_f.Set(20, _o29)
			_f.Set(21, _o30)
			_f.Set(22, _o31)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		coroutine.Yield[int, any](_o0)
		_f.IP = 3
		fallthrough
	case _f.IP < 5:
		switch {
		case _f.IP < 4:

			_o1 = 1
			_f.IP = 4
			fallthrough
		case _f.IP < 5:
			if true {
				coroutine.Yield[int, any](_o1)
			}
		}
		_f.IP = 5
		fallthrough
	case _f.IP < 6:

		coroutine.Yield[int, any](_o0)
		_f.IP = 6
		fallthrough
	case _f.IP < 8:
		switch {
		case _f.IP < 7:

			_o2 = 1
			_f.IP = 7
			fallthrough
		case _f.IP < 8:
			for ; _o2 < 3; _o2, _f.IP = _o2+1, 7 {
				coroutine.Yield[int, any](_o2)
			}
		}
		_f.IP = 8
		fallthrough
	case _f.IP < 9:

		coroutine.Yield[int, any](_o0)
		_f.IP = 9
		fallthrough
	case _f.IP < 16:
		switch {
		case _f.IP < 10:

			_o3 = 1
			_f.IP = 10
			fallthrough
		case _f.IP < 11:
			_o4 = _o3
			_f.IP = 11
			fallthrough
		case _f.IP < 16:
			switch {
			default:
				switch {
				case _f.IP < 12:
					_o5 = _o4 ==
						1
					_f.IP = 12
					fallthrough
				case _f.IP < 16:
					if _o5 {
						switch {
						case _f.IP < 15:
							switch {
							case _f.IP < 13:
								_o6 = 2
								_f.IP = 13
								fallthrough
							case _f.IP < 14:
								_o7 = _o6
								_f.IP = 14
								fallthrough
							case _f.IP < 15:
								switch {
								default:

									coroutine.Yield[int, any](_o6)
								}
							}
							_f.IP = 15
							fallthrough
						case _f.IP < 16:

							coroutine.Yield[int, any](_o3)
						}
					}
				}
			}
		}
		_f.IP = 16
		fallthrough
	case _f.IP < 17:

		coroutine.Yield[int, any](_o0)
		_f.IP = 17
		fallthrough
	case _f.IP < 21:
		switch {
		case _f.IP < 18:

			_o8 = 1
			_f.IP = 18
			fallthrough
		case _f.IP < 20:
			switch {
			case _f.IP < 19:

				_o9 = 2
				_f.IP = 19
				fallthrough
			case _f.IP < 20:
				coroutine.Yield[int, any](_o9)
			}
			_f.IP = 20
			fallthrough
		case _f.IP < 21:

			coroutine.Yield[int, any](_o8)
		}
		_f.IP = 21
		fallthrough
	case _f.IP < 22:

		coroutine.Yield[int, any](_o0)
		_f.IP = 22
		fallthrough
	case _f.IP < 23:
		_o10 = _o0
		_f.IP = 23
		fallthrough
	case _f.IP < 25:
		switch {
		case _f.IP < 24:

			_o11 = 1
			_f.IP = 24
			fallthrough
		case _f.IP < 25:
			coroutine.Yield[int, any](_o11)
		}
		_f.IP = 25
		fallthrough
	case _f.IP < 26:

		coroutine.Yield[int, any](_o10)
		_f.IP = 26
		fallthrough
	case _f.IP < 29:
		switch {
		case _f.IP < 28:
			switch {
			case _f.IP < 27:

				_o14 = 13
				_f.IP = 27
				fallthrough
			case _f.IP < 28:
				coroutine.Yield[int, any](_o14)
			}
			_f.IP = 28
			fallthrough
		case _f.IP < 29:

			coroutine.Yield[int, any](_o13)
		}
		_f.IP = 29
		fallthrough
	case _f.IP < 30:

		coroutine.Yield[int, any](_o12)
		_f.IP = 30
		fallthrough
	case _f.IP < 33:
		switch {
		case _f.IP < 31:
			_o17 = unsafe.Sizeof(_o16(0))
			_f.IP = 31
			fallthrough
		case _f.IP < 32:
			_o18 = int(_o17)
			_f.IP = 32
			fallthrough
		case _f.IP < 33:
			coroutine.Yield[int, any](_o18)
		}
		_f.IP = 33
		fallthrough
	case _f.IP < 34:
		_o19 = unsafe.Sizeof(_o15(0))
		_f.IP = 34
		fallthrough
	case _f.IP < 35:
		_o20 = int(_o19)
		_f.IP = 35
		fallthrough
	case _f.IP < 36:
		coroutine.Yield[int, any](_o20)
		_f.IP = 36
		fallthrough
	case _f.IP < 42:
		switch {
		case _f.IP < 37:
			_o24 = unsafe.Sizeof(_o23{})
			_f.IP = 37
			fallthrough
		case _f.IP < 38:
			_o25 = int(_o24)
			_f.IP = 38
			fallthrough
		case _f.IP < 39:
			coroutine.Yield[int, any](_o25)
			_f.IP = 39
			fallthrough
		case _f.IP < 40:
			_o28 = unsafe.Sizeof(_o27{})
			_f.IP = 40
			fallthrough
		case _f.IP < 41:
			_o29 = int(_o28)
			_f.IP = 41
			fallthrough
		case _f.IP < 42:
			coroutine.Yield[int, any](_o29)
		}
		_f.IP = 42
		fallthrough
	case _f.IP < 43:
		_o30 = unsafe.Sizeof(_o22{})
		_f.IP = 43
		fallthrough
	case _f.IP < 44:
		_o31 = int(_o30)
		_f.IP = 44
		fallthrough
	case _f.IP < 45:
		coroutine.Yield[int, any](_o31)
	}
}

//go:noinline
func RangeSliceIndexGenerator(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 []int
	var _o1 int
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			_o0 = _v.([]int)
		}
		_o1 = _f.Get(1).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = []int{10, 20, 30}
		_f.IP = 2
		fallthrough
	case _f.IP < 4:
		switch {
		case _f.IP < 3:
			_o1 = 0
			_f.IP = 3
			fallthrough
		case _f.IP < 4:
			for ; _o1 < len(_o0); _o1, _f.IP = _o1+1, 3 {
				coroutine.Yield[int, any](_o1)
			}
		}
	}
}

//go:noinline
func RangeArrayIndexValueGenerator(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 [3]int
	var _o1 int
	var _o2 int
	if _f.IP > 0 {
		_o0 = _f.Get(0).([3]int)
		_o1 = _f.Get(1).(int)
		_o2 = _f.Get(2).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = [...]int{10, 20, 30}
		_f.IP = 2
		fallthrough
	case _f.IP < 6:
		switch {
		case _f.IP < 3:
			_o1 = 0
			_f.IP = 3
			fallthrough
		case _f.IP < 6:
			for ; _o1 < len(_o0); _o1, _f.IP = _o1+1, 3 {
				switch {
				case _f.IP < 4:
					_o2 = _o0[_o1]
					_f.IP = 4
					fallthrough
				case _f.IP < 5:
					coroutine.Yield[int, any](_o1)
					_f.IP = 5
					fallthrough
				case _f.IP < 6:
					coroutine.Yield[int, any](_o2)
				}
			}
		}
	}
}

//go:noinline
func TypeSwitchingGenerator(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 []any
	var _o1 int
	var _o2 any
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			_o0 = _v.([]any)
		}
		_o1 = _f.Get(1).(int)
		if _v := _f.Get(2); _v != nil {
			_o2 = _v.(any)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = []any{int8(10), int16(20), int32(30), int64(40)}
		_f.IP = 2
		fallthrough
	case _f.IP < 12:
		switch {
		case _f.IP < 3:
			_o1 = 0
			_f.IP = 3
			fallthrough
		case _f.IP < 12:
			for ; _o1 < len(_o0); _o1, _f.IP = _o1+1, 3 {
				switch {
				case _f.IP < 4:
					_o2 = _o0[_o1]
					_f.IP = 4
					fallthrough
				case _f.IP < 8:
					switch _o2.(type) {
					case int8:
						coroutine.Yield[int, any](1)
					case int16:
						coroutine.Yield[int, any](2)
					case int32:
						coroutine.Yield[int, any](4)
					case int64:
						coroutine.Yield[int, any](8)
					}
					_f.IP = 8
					fallthrough
				case _f.IP < 12:
					switch v := _o2.(type) {
					case int8:
						coroutine.Yield[int, any](int(v))
					case int16:
						coroutine.Yield[int, any](int(v))
					case int32:
						coroutine.Yield[int, any](int(v))
					case int64:
						coroutine.Yield[int, any](int(v))
					}
				}
			}
		}
	}
}

//go:noinline
func LoopBreakAndContinue(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	var _o2 int
	var _o3 int
	var _o4 int
	var _o5 bool
	var _o6 bool
	var _o7 int
	var _o8 bool
	var _o9 bool
	if _f.IP > 0 {
		_o0 = _f.Get(0).(int)
		_o1 = _f.Get(1).(int)

		_o2 = _f.Get(2).(int)
		_o3 = _f.Get(3).(int)
		_o4 = _f.Get(4).(int)
		_o5 = _f.Get(5).(bool)
		_o6 = _f.Get(6).(bool)
		_o7 = _f.Get(7).(int)
		_o8 = _f.Get(8).(bool)
		_o9 = _f.Get(9).(bool)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_f.Set(4, _o4)
			_f.Set(5, _o5)
			_f.Set(6, _o6)
			_f.Set(7, _o7)
			_f.Set(8, _o8)
			_f.Set(9, _o9)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 6:
		switch {
		case _f.IP < 2:
			_o0 = 0
			_f.IP = 2
			fallthrough
		case _f.IP < 6:
		_l0:
			for ; _o0 < 10; _o0, _f.IP = _o0+1, 2 {
				switch {
				case _f.IP < 4:
					{
						_o1 = _o0 % 2
						if _o1 == 0 {
							continue _l0
						}
					}
					_f.IP = 4
					fallthrough
				case _f.IP < 5:
					if _o0 > 5 {
						break _l0
					}
					_f.IP = 5
					fallthrough
				case _f.IP < 6:

					coroutine.Yield[int, any](_o0)
				}
			}
		}
		_f.IP = 6
		fallthrough
	case _f.IP < 18:
		switch {
		case _f.IP < 7:

			_o2 = 0
			_f.IP = 7
			fallthrough
		case _f.IP < 18:
		_l1:
			for ; _o2 < 2; _o2, _f.IP = _o2+1, 7 {
				switch {
				case _f.IP < 8:
					_o3 = 0
					_f.IP = 8
					fallthrough
				case _f.IP < 18:
				_l2:
					for ; _o3 < 3; _o3, _f.IP = _o3+1, 8 {
						switch {
						case _f.IP < 9:
							coroutine.Yield[int, any](_o3)
							_f.IP = 9
							fallthrough
						case _f.IP < 18:
							{
								_o4 = _o3
								switch {
								default:
									{
										_o5 = _o4 ==
											0
										if _o5 {
											continue _l2
										} else {
											_o6 = _o4 ==

												1
											if _o6 {
												{
													_o7 = _o2
													switch {
													default:
														{
															_o8 = _o7 ==
																0
															if _o8 {
																continue _l1
															} else {
																_o9 = _o7 ==

																	1
																if _o9 {
																	break _l1
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//go:noinline
func RangeOverMaps(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 map[int]int
	var _o1 map[int]int
	var _o2 int
	var _o3 map[int]int
	var _o4 []int
	var _o5 []int
	var _o6 int
	var _o7 int
	var _o8 bool
	var _o9 map[int]int
	var _o10 []int
	var _o11 []int
	var _o12 int
	var _o13 int
	var _o14 int
	var _o15 bool
	var _o16 map[int]struct {
	}
	var _o17 int
	var _o18 map[int]struct {
	}
	var _o19 []int
	var _o20 []int
	var _o21 int
	var _o22 int
	var _o23 bool
	if _f.IP > 0 {
		n = _f.Get(0).(int)
		if _v := _f.Get(1); _v != nil {
			_o0 = _v.(map[int]int)
		}
		if _v := _f.Get(2); _v != nil {
			_o1 = _v.(map[int]int)
		}
		_o2 = _f.Get(3).(int)
		if _v := _f.Get(4); _v != nil {
			_o3 = _v.(map[int]int)
		}
		if _v := _f.Get(5); _v != nil {
			_o4 = _v.([]int)
		}
		if _v := _f.Get(6); _v != nil {
			_o5 = _v.([]int)
		}
		_o6 = _f.Get(7).(int)

		_o7 = _f.Get(8).(int)
		_o8 = _f.Get(9).(bool)
		if _v := _f.Get(10); _v != nil {
			_o9 = _v.(map[int]int)
		}
		if _v := _f.Get(11); _v != nil {
			_o10 = _v.([]int)
		}
		if _v := _f.Get(12); _v != nil {
			_o11 = _v.([]int)
		}
		_o12 = _f.Get(13).(int)

		_o13 = _f.Get(14).(int)
		_o14 = _f.Get(15).(int)
		_o15 = _f.Get(16).(bool)
		if _v := _f.Get(17); _v != nil {

			_o16 = _v.(map[int]struct {
			})
		}
		_o17 = _f.Get(18).(int)
		if _v := _f.Get(19); _v != nil {
			_o18 = _v.(map[int]struct {
			})
		}
		if _v := _f.Get(20); _v != nil {
			_o19 = _v.([]int)
		}
		if _v := _f.Get(21); _v != nil {
			_o20 = _v.([]int)
		}
		_o21 = _f.Get(22).(int)

		_o22 = _f.Get(23).(int)
		_o23 = _f.Get(24).(bool)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_f.Set(3, _o2)
			_f.Set(4, _o3)
			_f.Set(5, _o4)
			_f.Set(6, _o5)
			_f.Set(7, _o6)
			_f.Set(8, _o7)
			_f.Set(9, _o8)
			_f.Set(10, _o9)
			_f.Set(11, _o10)
			_f.Set(12, _o11)
			_f.Set(13, _o12)
			_f.Set(14, _o13)
			_f.Set(15, _o14)
			_f.Set(16, _o15)
			_f.Set(17, _o16)
			_f.Set(18, _o17)
			_f.Set(19, _o18)
			_f.Set(20, _o19)
			_f.Set(21, _o20)
			_f.Set(22, _o21)
			_f.Set(23, _o22)
			_f.Set(24, _o23)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = map[int]int{}
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		for range _o0 {
			panic("unreachable")
		}
		_f.IP = 3
		fallthrough
	case _f.IP < 4:
		for _ = range _o0 {
			panic("unreachable")
		}
		_f.IP = 4
		fallthrough
	case _f.IP < 5:
		for _, _ = range _o0 {
			panic("unreachable")
		}
		_f.IP = 5
		fallthrough
	case _f.IP < 6:
		_o0[n] = n * 10
		_f.IP = 6
		fallthrough
	case _f.IP < 9:
		switch {
		case _f.IP < 7:
			_o1 = _o0
			_f.IP = 7
			fallthrough
		case _f.IP < 9:
			switch {
			case _f.IP < 8:
				_o2 = 0
				_f.IP = 8
				fallthrough
			case _f.IP < 9:
				for ; _o2 < len(_o1); _o2, _f.IP = _o2+1, 8 {
					coroutine.Yield[int, any](0)
				}
			}
		}
		_f.IP = 9
		fallthrough
	case _f.IP < 17:
		switch {
		case _f.IP < 10:
			_o3 = _o0
			_f.IP = 10
			fallthrough
		case _f.IP < 12:
			{
				_o4 = make([]int, 0, len(_o3))
				for _v4 := range _o3 {
					_o4 = append(_o4, _v4)
				}
			}
			_f.IP = 12
			fallthrough
		case _f.IP < 17:
			switch {
			case _f.IP < 13:
				_o5 = _o4
				_f.IP = 13
				fallthrough
			case _f.IP < 17:
				switch {
				case _f.IP < 14:
					_o6 = 0
					_f.IP = 14
					fallthrough
				case _f.IP < 17:
					for ; _o6 < len(_o5); _o6, _f.IP = _o6+1, 14 {
						switch {
						case _f.IP < 15:
							_o7 = _o5[_o6]
							_f.IP = 15
							fallthrough
						case _f.IP < 17:
							switch {
							case _f.IP < 16:
								_, _o8 = _o3[_o7]
								_f.IP = 16
								fallthrough
							case _f.IP < 17:
								if _o8 {
									coroutine.Yield[int, any](_o7)
								}
							}
						}
					}
				}
			}
		}
		_f.IP = 17
		fallthrough
	case _f.IP < 26:
		switch {
		case _f.IP < 18:
			_o9 = _o0
			_f.IP = 18
			fallthrough
		case _f.IP < 20:
			{
				_o10 = make([]int, 0, len(_o9))
				for _v10 := range _o9 {
					_o10 = append(_o10, _v10)
				}
			}
			_f.IP = 20
			fallthrough
		case _f.IP < 26:
			switch {
			case _f.IP < 21:
				_o11 = _o10
				_f.IP = 21
				fallthrough
			case _f.IP < 26:
				switch {
				case _f.IP < 22:
					_o12 = 0
					_f.IP = 22
					fallthrough
				case _f.IP < 26:
					for ; _o12 < len(_o11); _o12, _f.IP = _o12+1, 22 {
						switch {
						case _f.IP < 23:
							_o13 = _o11[_o12]
							_f.IP = 23
							fallthrough
						case _f.IP < 26:
							switch {
							case _f.IP < 24:
								_o14, _o15 = _o9[_o13]
								_f.IP = 24
								fallthrough
							case _f.IP < 26:
								if _o15 {
									switch {
									case _f.IP < 25:
										coroutine.Yield[int, any](_o13)
										_f.IP = 25
										fallthrough
									case _f.IP < 26:
										coroutine.Yield[int, any](_o14)
									}
								}
							}
						}
					}
				}
			}
		}
		_f.IP = 26
		fallthrough
	case _f.IP < 27:

		_o16 = make(map[int]struct{}, n)
		_f.IP = 27
		fallthrough
	case _f.IP < 28:
		for _o17 = 0; _o17 < n; _o17++ {
			_o16[_o17] = struct{}{}
		}
		_f.IP = 28
		fallthrough
	case _f.IP < 29:
		coroutine.Yield[int, any](len(_o16))
		_f.IP = 29
		fallthrough
	case _f.IP < 38:
		switch {
		case _f.IP < 30:
			_o18 = _o16
			_f.IP = 30
			fallthrough
		case _f.IP < 32:
			{
				_o19 = make([]int, 0, len(_o18))
				for _v16 := range _o18 {
					_o19 = append(_o19, _v16)
				}
			}
			_f.IP = 32
			fallthrough
		case _f.IP < 38:
			switch {
			case _f.IP < 33:
				_o20 = _o19
				_f.IP = 33
				fallthrough
			case _f.IP < 38:
				switch {
				case _f.IP < 34:
					_o21 = 0
					_f.IP = 34
					fallthrough
				case _f.IP < 38:
					for ; _o21 < len(_o20); _o21, _f.IP = _o21+1, 34 {
						switch {
						case _f.IP < 35:
							_o22 = _o20[_o21]
							_f.IP = 35
							fallthrough
						case _f.IP < 38:
							switch {
							case _f.IP < 36:
								_, _o23 = _o18[_o22]
								_f.IP = 36
								fallthrough
							case _f.IP < 38:
								if _o23 {
									switch {
									case _f.IP < 37:
										delete(_o16, _o22)
										_f.IP = 37
										fallthrough
									case _f.IP < 38:
										coroutine.Yield[int, any](len(_o16))
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//go:noinline
func Range(n int, do func(int)) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	if _f.IP > 0 {
		n = _f.Get(0).(int)
		if _v := _f.Get(1); _v != nil {
			do = _v.(func(int))
		}
		_o0 = _f.Get(2).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, do)
			_f.Set(2, _o0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		for ; _o0 < n; _o0, _f.IP = _o0+1, 2 {
			do(_o0)
		}
	}
}

//go:noinline
func Double(n int) { coroutine.Yield[int, any](2 * n) }

//go:noinline
func RangeTriple(n int) {
	Range(n, func(i int) { coroutine.Yield[int, any](3 * i) })
}

//go:noinline
func RangeTripleFuncValue(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 func(int)
	if _f.IP > 0 {
		n = _f.Get(0).(int)
		if _v := _f.Get(1); _v != nil {
			_o0 = _v.(func(int))
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = func(i int) { coroutine.Yield[int, any](3 * i) }
		_f.IP = 2
		fallthrough
	case _f.IP < 3:

		Range(n, _o0)
	}
}

//go:noinline
func RangeReverseClosureCaptureByValue(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 func()
	if _f.IP > 0 {
		n = _f.Get(0).(int)
		_o0 = _f.Get(1).(int)
		if _v := _f.Get(2); _v != nil {
			_o1 = _v.(func())
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		_o1 = func() { coroutine.Yield[int, any](n - (_o0 + 1)) }
		_f.IP = 3
		fallthrough
	case _f.IP < 5:
		for ; _o0 < n; _f.IP = 3 {
			switch {
			case _f.IP < 4:
				_o1()
				_f.IP = 4
				fallthrough
			case _f.IP < 5:
				_o0++
			}
		}
	}
}

//go:noinline
func Range10ClosureCapturingValues() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	var _o2 func() bool
	var _o3 bool
	var _o4 bool
	if _f.IP > 0 {
		_o0 = _f.Get(0).(int)
		_o1 = _f.Get(1).(int)
		if _v := _f.Get(2); _v != nil {
			_o2 = _v.(func() bool)
		}
		_o3 = _f.Get(3).(bool)
		_o4 = _f.Get(4).(bool)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_f.Set(4, _o4)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		_o1 = 10
		_f.IP = 3
		fallthrough
	case _f.IP < 4:
		_o2 = func() (_ bool) {
			_c := coroutine.LoadContext[int, any]()
			_f, _fp := _c.Push()
			if _f.IP > 0 {
			}
			defer func() {
				if _c.Unwinding() {
					_c.Store(_fp, _f)
				} else {
					_c.Pop()
				}
			}()
			switch {
			case _f.IP < 4:
				if _o0 < _o1 {
					switch {
					case _f.IP < 2:
						coroutine.Yield[int, any](_o0)
						_f.IP = 2
						fallthrough
					case _f.IP < 3:
						_o0++
						_f.IP = 3
						fallthrough
					case _f.IP < 4:
						return true
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 5:

				return false
			}
			return
		}
		_f.IP = 4
		fallthrough
	case _f.IP < 7:
	_l0:
		for ; ; _f.IP = 4 {
			switch {
			case _f.IP < 5:
				_o3 = _o2()
				_f.IP = 5
				fallthrough
			case _f.IP < 6:
				_o4 = !_o3
				_f.IP = 6
				fallthrough
			case _f.IP < 7:
				if _o4 {
					break _l0
				}
			}
		}
	}
}

//go:noinline
func Range10ClosureCapturingPointers() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	var _o2 *int
	var _o3 *int
	var _o4 func() bool
	var _o5 bool
	var _o6 bool
	if _f.IP > 0 {
		_o0 = _f.Get(0).(int)
		_o1 = _f.Get(1).(int)
		if _v := _f.Get(2); _v != nil {
			_o2 = _v.(*int)
		}
		if _v := _f.Get(3); _v != nil {
			_o3 = _v.(*int)
		}
		if _v := _f.Get(4); _v != nil {
			_o4 = _v.(func() bool)
		}
		_o5 = _f.Get(5).(bool)
		_o6 = _f.Get(6).(bool)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_f.Set(4, _o4)
			_f.Set(5, _o5)
			_f.Set(6, _o6)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0, _o1 = 0, 10
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		_o2 = &_o0
		_f.IP = 3
		fallthrough
	case _f.IP < 4:
		_o3 = &_o1
		_f.IP = 4
		fallthrough
	case _f.IP < 5:
		_o4 = func() (_ bool) {
			_c := coroutine.LoadContext[int, any]()
			_f, _fp := _c.Push()
			if _f.IP > 0 {
			}
			defer func() {
				if _c.Unwinding() {
					_c.Store(_fp, _f)
				} else {
					_c.Pop()
				}
			}()
			switch {
			case _f.IP < 4:
				if *_o2 < *_o3 {
					switch {
					case _f.IP < 2:
						coroutine.Yield[int, any](*_o2)
						_f.IP = 2
						fallthrough
					case _f.IP < 3:
						(*_o2)++
						_f.IP = 3
						fallthrough
					case _f.IP < 4:
						return true
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 5:

				return false
			}
			return
		}
		_f.IP = 5
		fallthrough
	case _f.IP < 8:
	_l0:
		for ; ; _f.IP = 5 {
			switch {
			case _f.IP < 6:
				_o5 = _o4()
				_f.IP = 6
				fallthrough
			case _f.IP < 7:
				_o6 = !_o5
				_f.IP = 7
				fallthrough
			case _f.IP < 8:
				if _o6 {
					break _l0
				}
			}
		}
	}
}

//go:noinline
func Range10ClosureHeterogenousCapture() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o12 int8
	var _o13 int16
	var _o14 int32
	var _o15 int64
	var _o16 uint8
	var _o17 uint16
	var _o18 uint32
	var _o19 uint64
	var _o20 uintptr
	var _o21 func() int
	var _o22 int
	var _o23 func() bool
	var _o24 bool
	var _o25 bool
	if _f.IP > 0 {
		_o12 = _f.Get(0).(int8)
		_o13 = _f.Get(1).(int16)
		_o14 = _f.Get(2).(int32)
		_o15 = _f.Get(3).(int64)
		_o16 = _f.Get(4).(uint8)
		_o17 = _f.Get(5).(uint16)
		_o18 = _f.Get(6).(uint32)
		_o19 = _f.Get(7).(uint64)
		_o20 = _f.Get(8).(uintptr)
		if _v := _f.Get(9); _v != nil {
			_o21 = _v.(func() int)
		}

		_o22 = _f.Get(10).(int)
		if _v := _f.Get(11); _v != nil {
			_o23 = _v.(func() bool)
		}
		_o24 = _f.Get(12).(bool)
		_o25 = _f.Get(13).(bool)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o12)
			_f.Set(1, _o13)
			_f.Set(2, _o14)
			_f.Set(3, _o15)
			_f.Set(4, _o16)
			_f.Set(5, _o17)
			_f.Set(6, _o18)
			_f.Set(7, _o19)
			_f.Set(8, _o20)
			_f.Set(9, _o21)
			_f.Set(10, _o22)
			_f.Set(11, _o23)
			_f.Set(12, _o24)
			_f.Set(13, _o25)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 11:
		{
			_o12 = 0
			_o13 = 1
			_o14 = 2
			_o15 = 3
			_o16 = 4
			_o17 = 5
			_o18 = 6
			_o19 = 7
			_o20 = 8
			_o21 = func() int { return int(_o20) + 1 }
		}
		_f.IP = 11
		fallthrough
	case _f.IP < 12:

		_o22 = 0
		_f.IP = 12
		fallthrough
	case _f.IP < 13:
		_o23 = func() (_ bool) {
			_c := coroutine.LoadContext[int, any]()
			_f, _fp := _c.Push()
			var _o0 int
			var _o1 int
			var _o2 bool
			var _o3 bool
			var _o4 bool
			var _o5 bool
			var _o6 bool
			var _o7 bool
			var _o8 bool
			var _o9 bool
			var _o10 bool
			var _o11 bool
			if _f.IP > 0 {
				_o0 = _f.Get(0).(int)
				_o1 = _f.Get(1).(int)
				_o2 = _f.Get(2).(bool)
				_o3 = _f.Get(3).(bool)
				_o4 = _f.Get(4).(bool)
				_o5 = _f.Get(5).(bool)
				_o6 = _f.Get(6).(bool)
				_o7 = _f.Get(7).(bool)
				_o8 = _f.Get(8).(bool)
				_o9 = _f.Get(9).(bool)
				_o10 = _f.Get(10).(bool)
				_o11 = _f.Get(11).(bool)
			}
			defer func() {
				if _c.Unwinding() {
					_f.Set(0, _o0)
					_f.Set(1, _o1)
					_f.Set(2, _o2)
					_f.Set(3, _o3)
					_f.Set(4, _o4)
					_f.Set(5, _o5)
					_f.Set(6, _o6)
					_f.Set(7, _o7)
					_f.Set(8, _o8)
					_f.Set(9, _o9)
					_f.Set(10, _o10)
					_f.Set(11, _o11)
					_c.Store(_fp, _f)
				} else {
					_c.Pop()
				}
			}()
			switch {
			case _f.IP < 2:
				_f.IP = 2
				fallthrough
			case _f.IP < 13:
				switch {
				case _f.IP < 3:
					_o1 = _o22
					_f.IP = 3
					fallthrough
				case _f.IP < 13:
					switch {
					default:
						if _o2 = _o1 ==
							0; _o2 {
							_o0 = int(_o12)
						} else if _o3 = _o1 ==
							1; _o3 {
							_o0 = int(_o13)
						} else if _o4 = _o1 ==
							2; _o4 {
							_o0 = int(_o14)
						} else if _o5 = _o1 ==
							3; _o5 {
							_o0 = int(_o15)
						} else if _o6 = _o1 ==
							4; _o6 {
							_o0 = int(_o16)
						} else if _o7 = _o1 ==
							5; _o7 {
							_o0 = int(_o17)
						} else if _o8 = _o1 ==
							6; _o8 {
							_o0 = int(_o18)
						} else if _o9 = _o1 ==
							7; _o9 {
							_o0 = int(_o19)
						} else if _o10 = _o1 ==
							8; _o10 {
							_o0 = int(_o20)
						} else if _o11 = _o1 ==
							9; _o11 {
							_o0 = _o21()
						}
					}
				}
				_f.IP = 13
				fallthrough
			case _f.IP < 14:

				coroutine.Yield[int, any](_o0)
				_f.IP = 14
				fallthrough
			case _f.IP < 15:
				_o22++
				_f.IP = 15
				fallthrough
			case _f.IP < 16:
				return _o22 < 10
			}
			return
		}
		_f.IP = 13
		fallthrough
	case _f.IP < 16:
	_l0:
		for ; ; _f.IP = 13 {
			switch {
			case _f.IP < 14:
				_o24 = _o23()
				_f.IP = 14
				fallthrough
			case _f.IP < 15:
				_o25 = !_o24
				_f.IP = 15
				fallthrough
			case _f.IP < 16:
				if _o25 {
					break _l0
				}
			}
		}
	}
}

//go:noinline
func Range10Heterogenous() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int8
	var _o1 int16
	var _o2 int32
	var _o3 int64
	var _o4 uint8
	var _o5 uint16
	var _o6 uint32
	var _o7 uint64
	var _o8 uintptr
	var _o9 int
	var _o10 int
	if _f.IP > 0 {
		_o0 = _f.Get(0).(int8)
		_o1 = _f.Get(1).(int16)
		_o2 = _f.Get(2).(int32)
		_o3 = _f.Get(3).(int64)
		_o4 = _f.Get(4).(uint8)
		_o5 = _f.Get(5).(uint16)
		_o6 = _f.Get(6).(uint32)
		_o7 = _f.Get(7).(uint64)
		_o8 = _f.Get(8).(uintptr)

		_o9 = _f.Get(9).(int)
		_o10 = _f.Get(10).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_f.Set(4, _o4)
			_f.Set(5, _o5)
			_f.Set(6, _o6)
			_f.Set(7, _o7)
			_f.Set(8, _o8)
			_f.Set(9, _o9)
			_f.Set(10, _o10)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 10:
		{
			_o0 = 0
			_o1 = 1
			_o2 = 2
			_o3 = 3
			_o4 = 4
			_o5 = 5
			_o6 = 6
			_o7 = 7
			_o8 = 8
		}
		_f.IP = 10
		fallthrough
	case _f.IP < 23:
		switch {
		case _f.IP < 11:

			_o9 = 0
			_f.IP = 11
			fallthrough
		case _f.IP < 23:
			for ; _o9 < 10; _o9, _f.IP = _o9+1, 11 {
				switch {
				case _f.IP < 12:
					_f.IP = 12
					fallthrough
				case _f.IP < 22:

					switch _o9 {
					case 0:
						_o10 = int(_o0)
					case 1:
						_o10 = int(_o1)
					case 2:
						_o10 = int(_o2)
					case 3:
						_o10 = int(_o3)
					case 4:
						_o10 = int(_o4)
					case 5:
						_o10 = int(_o5)
					case 6:
						_o10 = int(_o6)
					case 7:
						_o10 = int(_o7)
					case 8:
						_o10 = int(_o8)
					case 9:
						_o10 = int(_o9)
					}
					_f.IP = 22
					fallthrough
				case _f.IP < 23:
					coroutine.Yield[int, any](_o10)
				}
			}
		}
	}
}

//go:noinline
func Select(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	var _o2 bool
	var _o3 int
	var _o4 int
	var _o5 <-chan time.Time
	var _o6 <-chan time.Time
	var _o7 int
	var _o8 bool
	var _o9 bool
	var _o10 int
	var _o11 <-chan time.Time
	var _o12 int
	var _o13 bool
	var _o14 int
	var _o15 <-chan time.Time
	var _o16 int
	var _o17 bool
	var _o18 int
	if _f.IP > 0 {
		n = _f.Get(0).(int)
		_o0 = _f.Get(1).(int)
		_o1 = _f.Get(2).(int)
		_o2 = _f.Get(3).(bool)

		_o3 = _f.Get(4).(int)
		_o4 = _f.Get(5).(int)
		if _v := _f.Get(6); _v != nil {
			_o5 = _v.(<-chan time.Time)
		}
		if _v := _f.Get(7); _v != nil {
			_o6 = _v.(<-chan time.Time)
		}
		_o7 = _f.Get(8).(int)
		_o8 = _f.Get(9).(bool)
		_o9 = _f.Get(10).(bool)
		_o10 = _f.Get(11).(int)
		if _v := _f.Get(12); _v != nil {
			_o11 = _v.(<-chan time.Time)
		}
		_o12 = _f.Get(13).(int)
		_o13 = _f.Get(14).(bool)
		_o14 = _f.Get(15).(int)
		if _v := _f.Get(16); _v != nil {
			_o15 = _v.(<-chan time.Time)
		}
		_o16 = _f.Get(17).(int)
		_o17 = _f.Get(18).(bool)

		_o18 = _f.Get(19).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_f.Set(3, _o2)
			_f.Set(4, _o3)
			_f.Set(5, _o4)
			_f.Set(6, _o5)
			_f.Set(7, _o6)
			_f.Set(8, _o7)
			_f.Set(9, _o8)
			_f.Set(10, _o9)
			_f.Set(11, _o10)
			_f.Set(12, _o11)
			_f.Set(13, _o12)
			_f.Set(14, _o13)
			_f.Set(15, _o14)
			_f.Set(16, _o15)
			_f.Set(17, _o16)
			_f.Set(18, _o17)
			_f.Set(19, _o18)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 6:
		switch {
		case _f.IP < 2:
			_o0 = 0
			_f.IP = 2
			fallthrough
		case _f.IP < 3:
			select {
			default:
				_o0 = 1
			}
			_f.IP = 3
			fallthrough
		case _f.IP < 6:
			switch {
			case _f.IP < 4:
				_o1 = _o0
				_f.IP = 4
				fallthrough
			case _f.IP < 6:
				switch {
				default:
					switch {
					case _f.IP < 5:
						_o2 = _o1 == 1
						_f.IP = 5
						fallthrough
					case _f.IP < 6:
						if _o2 {
							coroutine.Yield[int, any](-1)
						}
					}
				}
			}
		}
		_f.IP = 6
		fallthrough
	case _f.IP < 24:
		switch {
		case _f.IP < 7:

			_o3 = 0
			_f.IP = 7
			fallthrough
		case _f.IP < 24:
			for ; _o3 < n; _o3, _f.IP = _o3+1, 7 {
				switch {
				case _f.IP < 17:
					switch {
					case _f.IP < 8:
						_o4 = 0
						_f.IP = 8
						fallthrough
					case _f.IP < 9:
						_o5 = time.After(0)
						_f.IP = 9
						fallthrough
					case _f.IP < 10:
						_o6 = time.After(1 * time.Second)
						_f.IP = 10
						fallthrough
					case _f.IP < 12:
						select {
						case <-_o5:
							_o4 = 1
						case <-_o6:
							_o4 = 2
						}
						_f.IP = 12
						fallthrough
					case _f.IP < 17:
						switch {
						case _f.IP < 13:
							_o7 = _o4
							_f.IP = 13
							fallthrough
						case _f.IP < 17:
						_l2:
							switch {
							default:
								switch {
								case _f.IP < 14:
									_o8 = _o7 == 1
									_f.IP = 14
									fallthrough
								case _f.IP < 17:
									if _o8 {
										switch {
										case _f.IP < 15:
											if _o3 >= 5 {
												break _l2
											}
											_f.IP = 15
											fallthrough
										case _f.IP < 16:

											coroutine.Yield[int, any](_o3)
										}
									} else if _o9 = _o7 == 2; _o9 {

										panic("unreachable")
									}
								}
							}
						}
					}
					_f.IP = 17
					fallthrough
				case _f.IP < 24:
					switch {
					case _f.IP < 18:
						_o10 = 0
						_f.IP = 18
						fallthrough
					case _f.IP < 19:
						_o11 = time.After(0)
						_f.IP = 19
						fallthrough
					case _f.IP < 20:
						select {
						case <-_o11:
							_o10 = 1
						}
						_f.IP = 20
						fallthrough
					case _f.IP < 24:
						switch {
						case _f.IP < 21:
							_o12 = _o10
							_f.IP = 21
							fallthrough
						case _f.IP < 24:
						_l3:
							switch {
							default:
								switch {
								case _f.IP < 22:
									_o13 = _o12 == 1
									_f.IP = 22
									fallthrough
								case _f.IP < 24:
									if _o13 {
										switch {
										case _f.IP < 23:
											if _o3 >= 6 {
												break _l3
											}
											_f.IP = 23
											fallthrough
										case _f.IP < 24:

											coroutine.Yield[int, any](_o3 * 10)
										}
									}
								}
							}
						}
					}
				}
			}
		}
		_f.IP = 24
		fallthrough
	case _f.IP < 31:
		switch {
		case _f.IP < 25:
			_o14 = 0
			_f.IP = 25
			fallthrough
		case _f.IP < 26:
			_o15 = time.After(0)
			_f.IP = 26
			fallthrough
		case _f.IP < 27:
			select {
			case <-_o15:
				_o14 = 1
			}
			_f.IP = 27
			fallthrough
		case _f.IP < 31:
			switch {
			case _f.IP < 28:
				_o16 = _o14
				_f.IP = 28
				fallthrough
			case _f.IP < 31:
				switch {
				default:
					switch {
					case _f.IP < 29:
						_o17 = _o16 == 1
						_f.IP = 29
						fallthrough
					case _f.IP < 31:
						if _o17 {
							switch {
							case _f.IP < 30:
								_o18 = 0
								_f.IP = 30
								fallthrough
							case _f.IP < 31:
								for ; _o18 < 3; _o18, _f.IP = _o18+1, 30 {
									coroutine.Yield[int, any](_o18)
								}
							}
						}
					}
				}
			}
		}
	}
}

//go:noinline
func YieldingExpressionDesugaring() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	var _o2 int
	var _o3 int
	var _o4 bool
	var _o5 int
	var _o6 int
	var _o7 int
	var _o8 int
	var _o9 int
	var _o10 bool
	var _o11 int
	var _o12 int
	var _o13 int
	var _o14 int
	var _o15 int
	var _o16 bool
	var _o17 int
	var _o18 int
	var _o19 int
	var _o20 int
	var _o21 bool
	var _o22 bool
	var _o23 int
	var _o24 int
	var _o25 int
	var _o26 int
	var _o27 int
	var _o28 bool
	var _o29 int
	var _o30 int
	var _o31 bool
	var _o32 int
	var _o33 int
	var _o34 int
	var _o35 bool
	var _o36 int
	var _o37 int
	var _o38 int
	var _o39 bool
	var _o40 int
	var _o41 int
	var _o42 any
	if _f.IP > 0 {
		_o0 = _f.Get(0).(int)
		_o1 = _f.Get(1).(int)
		_o2 = _f.Get(2).(int)
		_o3 = _f.Get(3).(int)
		_o4 = _f.Get(4).(bool)
		_o5 = _f.Get(5).(int)
		_o6 = _f.Get(6).(int)
		_o7 = _f.Get(7).(int)
		_o8 = _f.Get(8).(int)
		_o9 = _f.Get(9).(int)
		_o10 = _f.Get(10).(bool)
		_o11 = _f.Get(11).(int)
		_o12 = _f.Get(12).(int)
		_o13 = _f.Get(13).(int)
		_o14 = _f.Get(14).(int)
		_o15 = _f.Get(15).(int)
		_o16 = _f.Get(16).(bool)
		_o17 = _f.Get(17).(int)

		_o18 = _f.Get(18).(int)
		_o19 = _f.Get(19).(int)
		_o20 = _f.Get(20).(int)
		_o21 = _f.Get(21).(bool)
		_o22 = _f.Get(22).(bool)
		_o23 = _f.Get(23).(int)

		_o24 = _f.Get(24).(int)
		_o25 = _f.Get(25).(int)
		_o26 = _f.Get(26).(int)
		_o27 = _f.Get(27).(int)
		_o28 = _f.Get(28).(bool)
		_o29 = _f.Get(29).(int)
		_o30 = _f.Get(30).(int)
		_o31 = _f.Get(31).(bool)
		_o32 = _f.Get(32).(int)
		_o33 = _f.Get(33).(int)
		_o34 = _f.Get(34).(int)
		_o35 = _f.Get(35).(bool)
		_o36 = _f.Get(36).(int)
		_o37 = _f.Get(37).(int)
		_o38 = _f.Get(38).(int)
		_o39 = _f.Get(39).(bool)
		_o40 = _f.Get(40).(int)
		_o41 = _f.Get(41).(int)
		if _v := _f.Get(42); _v != nil {
			_o42 = _v.(any)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_f.Set(4, _o4)
			_f.Set(5, _o5)
			_f.Set(6, _o6)
			_f.Set(7, _o7)
			_f.Set(8, _o8)
			_f.Set(9, _o9)
			_f.Set(10, _o10)
			_f.Set(11, _o11)
			_f.Set(12, _o12)
			_f.Set(13, _o13)
			_f.Set(14, _o14)
			_f.Set(15, _o15)
			_f.Set(16, _o16)
			_f.Set(17, _o17)
			_f.Set(18, _o18)
			_f.Set(19, _o19)
			_f.Set(20, _o20)
			_f.Set(21, _o21)
			_f.Set(22, _o22)
			_f.Set(23, _o23)
			_f.Set(24, _o24)
			_f.Set(25, _o25)
			_f.Set(26, _o26)
			_f.Set(27, _o27)
			_f.Set(28, _o28)
			_f.Set(29, _o29)
			_f.Set(30, _o30)
			_f.Set(31, _o31)
			_f.Set(32, _o32)
			_f.Set(33, _o33)
			_f.Set(34, _o34)
			_f.Set(35, _o35)
			_f.Set(36, _o36)
			_f.Set(37, _o37)
			_f.Set(38, _o38)
			_f.Set(39, _o39)
			_f.Set(40, _o40)
			_f.Set(41, _o41)
			_f.Set(42, _o42)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 21:
		switch {
		case _f.IP < 2:
			_o0 = b(1)
			_f.IP = 2
			fallthrough
		case _f.IP < 3:
			_o1 = a(_o0)
			_f.IP = 3
			fallthrough
		case _f.IP < 4:
			_o2 = b(2)
			_f.IP = 4
			fallthrough
		case _f.IP < 5:
			_o3 = a(_o2)
			_f.IP = 5
			fallthrough
		case _f.IP < 6:
			_o4 = _o1 == _o3
			_f.IP = 6
			fallthrough
		case _f.IP < 21:
			if _o4 {
			} else {
				switch {
				case _f.IP < 8:
					_o5 = b(3)
					_f.IP = 8
					fallthrough
				case _f.IP < 9:
					_o6 = a(_o5)
					_f.IP = 9
					fallthrough
				case _f.IP < 10:
					_o7 = b(4)
					_f.IP = 10
					fallthrough
				case _f.IP < 11:
					_o8 = a(_o7)
					_f.IP = 11
					fallthrough
				case _f.IP < 12:
					_o9 = _o8 - 1
					_f.IP = 12
					fallthrough
				case _f.IP < 13:
					_o10 = _o6 == _o9
					_f.IP = 13
					fallthrough
				case _f.IP < 21:
					if _o10 {
						switch {
						case _f.IP < 14:
							_o11 = b(5)
							_f.IP = 14
							fallthrough
						case _f.IP < 15:
							_o12 = a(_o11)
							_f.IP = 15
							fallthrough
						case _f.IP < 16:
							_o13 = _o12 * 10
							_f.IP = 16
							fallthrough
						case _f.IP < 17:
							coroutine.Yield[int, any](_o13)
						}
					} else {
						switch {
						case _f.IP < 18:
							_o14 = b(100)
							_f.IP = 18
							fallthrough
						case _f.IP < 19:
							_o15 = a(_o14)
							_f.IP = 19
							fallthrough
						case _f.IP < 20:
							_o16 = _o15 == 100
							_f.IP = 20
							fallthrough
						case _f.IP < 21:
							if _o16 {
								panic("unreachable")
							}
						}
					}
				}
			}
		}
		_f.IP = 21
		fallthrough
	case _f.IP < 29:
		switch {
		case _f.IP < 22:
			_o17 = b(6)
			_f.IP = 22
			fallthrough
		case _f.IP < 23:
			_o18 = a(_o17)
			_f.IP = 23
			fallthrough
		case _f.IP < 29:
		_l0:
			for ; ; _o18, _f.IP = _o18+1, 23 {
				switch {
				case _f.IP < 28:
					switch {
					case _f.IP < 24:
						_o19 = b(8)
						_f.IP = 24
						fallthrough
					case _f.IP < 25:
						_o20 = a(_o19)
						_f.IP = 25
						fallthrough
					case _f.IP < 26:
						_o21 = _o18 < _o20
						_f.IP = 26
						fallthrough
					case _f.IP < 27:
						_o22 = !_o21
						_f.IP = 27
						fallthrough
					case _f.IP < 28:
						if _o22 {
							break _l0
						}
					}
					_f.IP = 28
					fallthrough
				case _f.IP < 29:
					coroutine.Yield[int, any](70)
				}
			}
		}
		_f.IP = 29
		fallthrough
	case _f.IP < 51:
		switch {
		case _f.IP < 30:
			_o23 = b(9)
			_f.IP = 30
			fallthrough
		case _f.IP < 31:
			_o24 = a(_o23)
			_f.IP = 31
			fallthrough
		case _f.IP < 32:
			_o25 = _o24
			_f.IP = 32
			fallthrough
		case _f.IP < 51:
			switch {
			default:
				switch {
				case _f.IP < 33:
					_o26 = b(10)
					_f.IP = 33
					fallthrough
				case _f.IP < 34:
					_o27 = a(_o26)
					_f.IP = 34
					fallthrough
				case _f.IP < 35:
					_o28 = _o25 == _o27
					_f.IP = 35
					fallthrough
				case _f.IP < 51:
					if _o28 {
						panic("unreachable")
					} else {
						switch {
						case _f.IP < 37:
							_o29 = b(11)
							_f.IP = 37
							fallthrough
						case _f.IP < 38:
							_o30 = a(_o29)
							_f.IP = 38
							fallthrough
						case _f.IP < 39:
							_o31 = _o25 == _o30
							_f.IP = 39
							fallthrough
						case _f.IP < 51:
							if _o31 {
								panic("unreachable")
							} else {
								switch {
								case _f.IP < 41:
									_o32 = b(12)
									_f.IP = 41
									fallthrough
								case _f.IP < 42:
									_o33 = a(_o32)
									_f.IP = 42
									fallthrough
								case _f.IP < 43:
									_o34 = _o33 - 3
									_f.IP = 43
									fallthrough
								case _f.IP < 44:
									_o35 = _o25 == _o34
									_f.IP = 44
									fallthrough
								case _f.IP < 51:
									if _o35 {
										switch {
										case _f.IP < 45:
											_o36 = b(13)
											_f.IP = 45
											fallthrough
										case _f.IP < 46:
											a(_o36)
										}
									} else {
										switch {
										case _f.IP < 47:
											_o37 = b(14)
											_f.IP = 47
											fallthrough
										case _f.IP < 48:
											_o38 = a(_o37)
											_f.IP = 48
											fallthrough
										case _f.IP < 49:
											_o39 = _o25 == _o38
											_f.IP = 49
											fallthrough
										case _f.IP < 51:
											if _o39 {
												panic("unreachable")
											} else {
												panic("unreachable")
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		_f.IP = 51
		fallthrough
	case _f.IP < 57:
		switch {
		case _f.IP < 52:
			_o40 = b(15)
			_f.IP = 52
			fallthrough
		case _f.IP < 53:
			_o41 = a(_o40)
			_f.IP = 53
			fallthrough
		case _f.IP < 54:
			_o42 = any(_o41)
			_f.IP = 54
			fallthrough
		case _f.IP < 57:
			switch x := _o42.(type) {
			case bool:
				panic("unreachable")
			case int:
				coroutine.Yield[int, any](x * 10)
			default:
				panic("unreachable")
			}
		}
	}
}

//go:noinline
func a(v int) (_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	if _f.IP > 0 {
		v = _f.Get(0).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, v)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		coroutine.Yield[int, any](v)
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		return v
	}
	return
}

//go:noinline
func b(v int) (_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	if _f.IP > 0 {
		v = _f.Get(0).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, v)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		coroutine.Yield[int, any](-v)
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		return v
	}
	return
}

//go:noinline
func YieldingDurations() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o3 *time.Duration
	var _o4 time.Duration
	var _o5 func()
	var _o6 int
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			_o3 = _v.(*time.Duration)
		}
		_o4 = _f.Get(1).(time.Duration)
		if _v := _f.Get(2); _v != nil {

			_o5 = _v.(func())
		}

		_o6 = _f.Get(3).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o3)
			_f.Set(1, _o4)
			_f.Set(2, _o5)
			_f.Set(3, _o6)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o3 = new(time.Duration)
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		_o4 = time.Duration(100)
		_f.IP = 3
		fallthrough
	case _f.IP < 4:
		*_o3 = _o4
		_f.IP = 4
		fallthrough
	case _f.IP < 5:

		_o5 = func() {
			_c := coroutine.LoadContext[int, any]()
			_f, _fp := _c.Push()
			var _o0 int64
			var _o1 int
			var _o2 time.Duration
			if _f.IP > 0 {
				_o0 = _f.Get(0).(int64)
				_o1 = _f.Get(1).(int)
				_o2 = _f.Get(2).(time.Duration)
			}
			defer func() {
				if _c.Unwinding() {
					_f.Set(0, _o0)
					_f.Set(1, _o1)
					_f.Set(2, _o2)
					_c.Store(_fp, _f)
				} else {
					_c.Pop()
				}
			}()
			switch {
			case _f.IP < 2:
				_o0 = _o3.Nanoseconds()
				_f.IP = 2
				fallthrough
			case _f.IP < 3:
				_o1 = int(_o0)
				_f.IP = 3
				fallthrough
			case _f.IP < 4:
				_o2 = time.Duration(_o1 + 1)
				_f.IP = 4
				fallthrough
			case _f.IP < 5:
				*_o3 = _o2
				_f.IP = 5
				fallthrough
			case _f.IP < 6:
				coroutine.Yield[int, any](_o1)
			}
		}
		_f.IP = 5
		fallthrough
	case _f.IP < 7:
		switch {
		case _f.IP < 6:

			_o6 = 0
			_f.IP = 6
			fallthrough
		case _f.IP < 7:
			for ; _o6 < 10; _o6, _f.IP = _o6+1, 6 {
				_o5()
			}
		}
	}
}
